// debug_io.h
#pragma once
#include <fstream>
#include <iomanip>
#include <limits>
#include <string>
#include <type_traits>
#include <Eigen/Sparse>

/**
 * Write an Eigen::SparseMatrix to a Matrix Market .mtx file:
 *
 * Header:
 *   %%MatrixMarket matrix coordinate real general
 *   % optional comments...
 *   rows cols nnz
 * Then one line per kept nonzero: "row col value" (1-based indices).
 *
 * A relative cutoff is applied: let m = max_{(i,j)} |A_ij|.
 * Any entry with |A_ij| < cutoff_rel * m is NOT written.
 * Default cutoff_rel = 0.0 keeps all nonzeros.
 *
 * NOTE: Matrix Market requires 1-based indices. We therefore enforce one_based=true.
 *
 * @param path        Output file path.
 * @param A           Sparse matrix (need not be compressed).
 * @param cutoff_rel  Relative cutoff in [0, +inf). Default 0.0 (no drop).
 * @param precision   Floating output precision (default 17).
 */
template <class Scalar>
inline void write_mtx(const std::string& path,
                      const Eigen::SparseMatrix<Scalar>& A,
                      double cutoff_rel = 0.0,
                      int precision = 17)
{
    static_assert(std::is_floating_point<Scalar>::value,
                  "write_mtx expects a real floating-point Scalar (float/double/long double).");

    std::ofstream os(path, std::ios::out | std::ios::trunc);
    if (!os) throw std::runtime_error("write_mtx: could not open '" + path + "'");

    // Work on a compressed copy for stable iteration order.
    Eigen::SparseMatrix<Scalar> M = A;
    M.makeCompressed();

    const auto R  = static_cast<long long>(M.rows());
    const auto C  = static_cast<long long>(M.cols());

    // Pass 1: compute max absolute value among stored entries.
    long double max_abs = 0.0L;
    for (int k = 0; k < M.outerSize(); ++k)
        for (typename Eigen::SparseMatrix<Scalar>::InnerIterator it(M, k); it; ++it)
        {
            long double v = static_cast<long double>(it.value());
            long double a = v >= 0 ? v : -v; // fabs without headers
            if (a > max_abs) max_abs = a;
        }

    // Effective threshold (treat negative cutoff as zero).
    const long double thr = (cutoff_rel > 0.0) ? static_cast<long double>(cutoff_rel) * max_abs : 0.0L;

    // Pass 2: count how many survive the cutoff.
    long long kept_nnz = 0;
    for (int k = 0; k < M.outerSize(); ++k)
        for (typename Eigen::SparseMatrix<Scalar>::InnerIterator it(M, k); it; ++it)
        {
            long double a = it.value() >= 0 ? static_cast<long double>(it.value())
                                            : -static_cast<long double>(it.value());
            if (a >= thr) ++kept_nnz;
        }

    // Header: Matrix Market REAL GENERAL with 1-based indices.
    os << "%%MatrixMarket matrix coordinate real general\n";
    os << "% generated by FEMaster showing all values |x| >= " << std::setprecision(10) << cutoff_rel * max_abs << "\n";
    os.unsetf(std::ios::floatfield); // back to default before sizes
    os << R << " " << C << " " << kept_nnz << "\n";

    // Values: scientific with requested precision
    os.setf(std::ios::scientific);
    os << std::setprecision(precision);

    // Pass 3: write kept entries, 1-based.
    for (int k = 0; k < M.outerSize(); ++k)
        for (typename Eigen::SparseMatrix<Scalar>::InnerIterator it(M, k); it; ++it)
        {
            long double a = it.value() >= 0 ? static_cast<long double>(it.value())
                                            : -static_cast<long double>(it.value());
            if (a < thr) continue;

            long long r = static_cast<long long>(it.row()) + 1; // 1-based
            long long c = static_cast<long long>(it.col()) + 1; // 1-based
            os << r << " " << c << " " << static_cast<long double>(it.value()) << "\n";
        }
}

/**
 * Convenience overload for dense matrices: internally converts to sparse,
 * then applies the same relative cutoff strategy and Matrix Market output.
 */
template <class Derived>
inline void write_mtx_dense(const std::string& path,
                            const Eigen::MatrixBase<Derived>& A,
                            double cutoff_rel = 0.0,
                            int precision = 17)
{
    using Scalar = typename Derived::Scalar;
    static_assert(std::is_floating_point<Scalar>::value,
                  "write_mtx_dense expects a real floating-point Scalar (float/double/long double).");

    // Convert to sparse view (zero entries are dropped by construction).
    Eigen::SparseMatrix<Scalar> S = A.sparseView();
    write_mtx(path, S, cutoff_rel, precision);
}
